###

1. r - l + 1

2. 

### Good Sites for Undestanding things
https://visualgo.net/ -> Can see how algorithm works

### Python Goctha's 

1. If I want to do reverse for loop which need values  `from 0 to 10` then I need to use 
    `for i in range(10, -1, -1):` 
    https://stackoverflow.com/questions/3476732/how-to-loop-backwards-in-python
2. For Queue I can use `deque` and the code to import is `from collections import deque`

3. Concatenating a string in python




### If an 1d Array sum is given
    What All Topics are covered in this
        1. Normal Arrays
        2. SubSequence and Subsets
        3. 2d arrays
    It can be solved using
        1. Prefix Sum 
        2. Suffix Sum
        2. Sliding WIndow
        3. Carry Forward
        4. Kadane Algo
        5. 2 pointer
        6. Contribution technique (This is used in subarray problems of intermidiate)
        7. hash methods
        8. Propogation technique (Prefix sum)


### 2D Martix Approach
    - In a 2d matrix or A[n][m] 
        Top left -> A[0][0] 
        Top Right -> A[0][m - 1]
        Bottom Right -> A[n - 1][m - 1]
        Bottom Left -> A[n - 1][0]
    
    - In a square matrix the diagonal left to right there is an observation 
        i == j

    - IMP Observation, there can be cases when you are given a square matrix then you dont need to for a 2 for loop
    eg : A[N][M] is a square matrix where N == M then for i in range(m) is enough

    - In a square matrix for diagonal right to left there is an observation
        Row is increased and columns is decreased
    
    Observation: Matrix question may not be solved in one loop condition, will need step 1 and step 2

    - For Upper Triangular Matrix and to print only upper triangular see this example
        [
            [1 2 3 4] 
            [5 6 7 8] 
            [9 10 11 12] 
            [13 14 15 16]
        ]

        for i in range(0, len(A))
            for j in range(i + 1, len(A))

### Bit Manupulation 

    https://github.com/kushagra414/Dynamic-Programming/blob/master/Bit%20Manipulation%20Cheat%20Sheet.md

    https://www.geeksforgeeks.org/bits-manipulation-important-tactics/

    https://scaler-production-new.s3.ap-southeast-1.amazonaws.com/attachments/attachments/000/007/352/original/Bit_manipulation_adv_febdec.pdf?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAIDNNIRGHAQUQRWYA%2F20230401%2Fap-southeast-1%2Fs3%2Faws4_request&X-Amz-Date=20230401T124853Z&X-Amz-Expires=561600&X-Amz-SignedHeaders=host&X-Amz-Signature=04bdcde24a02ab601353fd767551d7ae488fca15e331f863032dfa9c3cd2b3ff

    - In a bit manupulation problem it is always doing a for loop on the number of bits
    - We can also apply contribution Technique to find


    1. Geometric Progression
        If in a sequence of terms, each succeeding term is generated by multiplying each preceding term with a constant value
        eg: 4, 8, 16, 32, 64, â€¦ is a GP

        2^0 + 2^1 + 2^2 + 2^3 + 2^4 + 2^5  
        if you are given this progression and need to find 2^7 then the answer would be
            Sum of GP = a(r^n - 1)/ r - 1  where a = 1, r =  2, n = 7
        Once after putting all the values in I get the answer as
                        = 2^7 - 1
        which can be described as 
                        = 2^n -1
    

    2. In python to convert decimal to Binary use bin() and for opposite use int()

    3. The negative Numbers in binary can be achieved by https://realpython.com/lessons/number-representations/
        1. making a 1's compliment of the number
        2. add +1
    
    4. Properties for Logical Operators
        1. A & 1 = 1 then it's odd
        2. A & 1 = 0 then it's even
        3. A & A = A
        4. A & 0 = A
        5. A | A = A
        6. A | 0 = A
        7. A ^ A = 0
        8. A ^ 0 = A

    5. Left Shifting (<<)
        1. Left shifting a number by 1 increases the value 2 times i.e 2^n times
            5 << 1 = 5 * 2^1 = 10
            5 << 2 = 5 * 2^2 = 20
            5 << 3 = 5 * 2^3 = 40
            and so on
            Hence, a << i = a * 2^i

            1 << n = 1 * 2^n = 2^n
    
    6. Right Shifting (>>)
        1. Right shifting a number by 1 decreases the value by 2^n times
            50 >> 1 = 50 * 1/2^1 = 25
            50 >> 2 = 50 * 1/2^2 = 12
            50 >> 3 = 50 * 1/2^3 = 6
            50 >> 4 = 50 * 1/2^4 = 3
            50 >> 5 = 50 * 1/2^5 = 1
            50 >> 6 = 50 * 1/2^6 = 0
            50 >> 7 = 50 * 1/2^7 = 0

            Hence, we can see that when doing continously right shifting we get till the answer as 0 and the rest answer will always be zero


            a >> n = a/2^n

    
    7. Check if two integers have opposite signs
        if(x^y >0)
            return false;
        else
            return true;

    8. Multiply a number by 2 -> x<<1;

    9. Divide a number by 2 -> x>>1;

    10. Turn off the rightmost set bit -> x&(x-1);

    11. Turn off a particular bit in a number -> x & (~(1 << i))

    12. Swap three variables
        x = x ^ y ^ z;
        y = x ^ y ^ z;
        z = x ^ y ^ z;
        x = x ^ y ^ z;

    13.  How to know if a number is a power of 2?
        return x and (not(x & (x - 1)))

    14. The Quickest way to swap two numbers:
        a ^= b;
        b ^= a; 
        a ^= b;

    15. for checking ith bit is set (value>>position)&1==1:


### Recursion

1. 3 Golden Steps of Recursion
    1. Assumption: What do you want your function to do
    2. Main Logic: How to solve the problem using smaller sub problem
    3. Base Condition: When do you want to stop

2. For time complexity there is something called as substitution method which is used

3. Very Important to see if you are returning everything that is needed or else you may end up getting None

### Sorting

1. There is something called as inplace sorting which means it doesn't use extra space for sorting




2. Types of Sorting Algorithm
    1. Selection Sort
        The definition of selection sort is that if you find a thing to be swapped' let's say a number then you swap it with the index.
        The sort is not stable
        This is an inplace sorting
        Time Complexity O(n^2)
        Space Complexity 0(1)
    2. Bubble Sort
        Sorting happens only on the adjacent elements in the array 
        after every sort depending on the condition you will get 1st, 2nd, 3rd ... max or min on the right position
        Time Complexity O(n^2)
        This sort is stable, duplicate element is not interchanging

    3. Merge Sort
    4. Quick Sort
    5. Insertion Sort
    6.
    7. To learn all these sort and to visualise this there is a site 
        https://visualgo.net/en/sorting?slide=6-5

3. There is also something called as comparators which is also something that is used 

4. 